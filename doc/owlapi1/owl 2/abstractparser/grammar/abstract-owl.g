/*
 * Copyright (C) 2003 The University of Manchester 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA.
 *
 ****************************************************************
 * Source code information
 * -----------------------
 * Filename           $RCSfile: abstract-owl.g,v $
 * Revision           $Revision: 1.4 $
 * Release status     $State: Exp $
 * Last modified on   $Date: 2004/02/19 15:17:44 $
 *               by   $Author: dturi $
 ****************************************************************/

header {
package org.semanticweb.owl.io.abstract_syntax; 

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;

import java.net.URI; 
import java.net.URISyntaxException; 

import java.util.Iterator; 
import java.util.Map; 
import java.util.HashMap; 
import java.util.Set; 
import java.util.HashSet; 

import java.util.logging.Logger;

import org.semanticweb.owl.model.OWLException;
import org.semanticweb.owl.model.OWLAnnotationProperty;
import org.semanticweb.owl.model.OWLDescription;
import org.semanticweb.owl.model.OWLIndividual;
import org.semanticweb.owl.model.OWLClass;
import org.semanticweb.owl.model.OWLObjectProperty;
import org.semanticweb.owl.model.OWLRestriction;
import org.semanticweb.owl.model.OWLDataType;
import org.semanticweb.owl.model.OWLDataProperty;
import org.semanticweb.owl.model.OWLDataRestriction;
import org.semanticweb.owl.model.OWLDataRange;
import org.semanticweb.owl.model.OWLDataValue;
import org.semanticweb.owl.model.OWLCardinalityRestriction;
import org.semanticweb.owl.model.OWLObjectRestriction;
import org.semanticweb.owl.model.OWLOntology;
import org.semanticweb.owl.model.helper.OWLBuilder;
}

/**  
 * <a href="http://www.antlr.org/">ANTLR</a> generated parser for 
 * <a href="http://owl.man.ac.uk/2003/concrete/latest/">OWL abstract 
 * syntax</a>. It is invoked by {@link AbstractOWLParser} which implements
 * {@link org.semanticweb.owl.io.Parser}.
 * Builds two tables: <code>a namespaceTable</code> with all name spaces
 * used in the ontology and 
 * an <code>idsTable</code> with the types
 * of the <code>OWLProperty</code>s which can be inferred from
 * the ontology. 
 * While parsing an ontology, builds a corresponding {@link OWLOntology}
 * using the utility class {@link OWLBuilder}.
 * <p>
 * Generated by <a href="http://www.antlr.org/">ANTLR</a>
 * from file <code>abstract-owl.g</code>.
 * Relies on {@link AbstractOWLLexer}.
 * </p>
 * <p>
 * <strong>Warning:</strong>
 * <code>ObjectProperty</code> and 
 * <code>DatatypeProperty</code> entities have to be defined 
 * before they can be used.
 * Eg: </p>
 * <ul>
 * <li><em>VALID</em>
 * <pre>
 *    Namespace(people=&lt;http://cohse.semanticweb.org/ontologies/people#&gt;)
 *    Ontology( 
 *      ObjectProperty(people:has_pet)
 *      Individual(people:fred value(people:has_pet people:felix))
 *    )
 * </pre></li>
 * <li><em>NOT VALID</em>
 * <pre>
 *    Namespace(people=&lt;http://cohse.semanticweb.org/ontologies/people#&gt;)
 *    Ontology( 
 *      Individual(people:fred value(people:has_pet people:felix))
 *      ObjectProperty(people:has_pet)
 *    )
 * </pre></li>
 * </ul>
 */
class ANTLRParser extends Parser; 

  options {
    importVocab = OWL; // Tokens generated by lexer.g
    k = 4;
  }
  
  {

    static Logger logger = Logger.getLogger("ANTLRParser");

    /**
     * Main helper to build the OWLOntology.
     */
    public OWLBuilder builder;

    final static public String DATA_PROPERTY = "Data Property";
    final static public String OBJ_PROP = "Object Property";
    final static public String ANN_PROP = "Annotation Property";
    final static public String ONTO_PROP = "Ontology Property";

    /**
     * Used to disambiguate the property types.
     * Keys are String representations of OWLProperty URIs and 
     * values are either of the following:
     * <ul>
     * <li>{@link #OBJ_PROP}</li>
     * <li>{@link #DATA_PROPERTY}</li>
     * <li>{@link #ANN_PROP}</li>
     * <li>{@link #ONTO_PROP}</li>
     * </ul>
     */
    Map idsTable = new HashMap();

    /**
     * Get the IdsTable value.
     * @return the IdsTable value.
     */
    public Map getIdsTable() {
	return idsTable;
    }

    /**
     * Set the IdsTable value.
     * @param newIdsTable The new IdsTable value.
     */
    public void setIdsTable(Map newIdsTable) {
	this.idsTable = newIdsTable;
    }

    /**
     * Used to store the namespaces.
     * Keys are prefixes and values are (String
     * representations of) absolute URIs.
     */
    Map namespaceTable = new HashMap();

    /**
     * Get the NamespaceTable value.
     * @return the NamespaceTable value.
     */
    public Map getNamespaceTable() {
	return namespaceTable;
    }

    /**
     * Set the NamespaceTable value.
     * @param newNamespaceTable The new NamespaceTable value.
     */
    public void setNamespaceTable(Map newNamespaceTable) {
	this.namespaceTable = newNamespaceTable;
    }

    final public static URI RDFS_LIT_URI =
	URI.create("http://www.w3.org/2000/01/rdf-schema#Literal");

    final public static int DATA_PROP_INT = 1;
    final public static int OBJ_PROP_INT = 2;
    final public static int ANN_PROP_INT = 3;
    final public static int ONT_PROP_INT = 4;

    SomeUndefinedOWLPropertyHandler propertyHandler =
      new SomeUndefinedOWLPropertyLaxHandler();

    /**
     * Sets the <code>propertyHandler</code> property to <code>handler</code>.
     *
     * @param handler a <code>SomeUndefinedOWLPropertyHandler</code> value
     */
    public void setPropertyHandler(SomeUndefinedOWLPropertyHandler handler) {
      propertyHandler = handler;
    }

    /**
     * Compares the Strings in <code>ids</code> with the keys
     * in <code>idsTable</code> and returns the first not null type 
     * in the form of
     * one of {@link #DATA_PROP_INT}, {@link #OBJ_PROP_INT},
     * {@link #ANN_PROP_INT}, {@link #ONT_PROP_INT}.
     *
     * @param ids a Set of Strings corresponding to property uris.
     * @exception UndefinedOWLPropertyException if no property type
     * is defined.
     * @exception SomeUndefinedOWLPropertyException if the
     * property type can be inferred but some properties are undefined; 
     * the exception might beeen have handled by
     * the {@link SomeUndefinedOWLPropertyHandler} though.
     */
    public int inferPropertyType(Set ids) 
	throws UndefinedOWLPropertyException, 
	       UndefinedOWLPropertyTypeException,
	       SomeUndefinedOWLPropertyException
    {
      String idType;
      boolean isSomeUndefined = false;
      for (Iterator i = ids.iterator(); i.hasNext(); ) {
        idType = (String)idsTable.get((String)i.next()); 
        if (idType == null) isSomeUndefined = true;
        else {
          if (isSomeUndefined) 
            propertyHandler.handle(new SomeUndefinedOWLPropertyException
                                   (getIntValue(idType)));
          return getIntValue(idType);
        }
      }
      throw new UndefinedOWLPropertyException(ids);
    }

    static int getIntValue(String propertyType) 
	throws UndefinedOWLPropertyTypeException
    {
      if (propertyType.equals(DATA_PROPERTY))
        return DATA_PROP_INT;
      if (propertyType.equals(OBJ_PROP))
        return OBJ_PROP_INT;
      if (propertyType.equals(ANN_PROP))
        return ANN_PROP_INT;
      if (propertyType.equals(ONTO_PROP))
        return ONT_PROP_INT;          
      throw new UndefinedOWLPropertyTypeException(propertyType);
    }	 

    static URI createURI(String uriString) 
	throws MalformedOWLURIException 
    {
      try {
        return new URI(uriString);
      } catch (URISyntaxException e) {
          throw new MalformedOWLURIException(uriString, e);
      }
    }

    static String removeHeadAndTail(String s) {
      return s.substring(1, s.length()-1); 
    }
    
    static String removeTail(String s) {
      return s.substring(0, s.length()-1); 
    }

  }

  /**
   * <strong>Starting rule</strong>.
   * Parses an OWL abstract syntax ontology and returns
   * the corresponding OWLOntology. 
   */ 
  ontology [URI physicalURI, OWLBuilder builder]
	returns [OWLOntology owlOntology] throws OWLException
    { this.builder = builder;
      idsTable = new HashMap();
      owlOntology = null;
      URI id = null;
    }
    : ( namespace )*
      ONTOLOGY
          ( id = ontologyID )? 
            { builder.createOntology(id, physicalURI); }
          ( directive )* 
        RPAREN
      { owlOntology = builder.getOntology(); 
        logger.fine(namespaceTable.toString()); 
		logger.fine(idsTable.toString()); }
    ;

  /**
   * Namespace <em>rule</em>: populates <code>namespaceTable</code>.
   */ 
  namespace 
    : NAMESPACE
	  p:PREFIX { String prefix = p.getText(); }
	  EQUAL
	  u:URI_ID { String uri = removeHeadAndTail(u.getText()); }
	  RPAREN
	  { namespaceTable.put(prefix, uri); }
    ;

  /**
   * Rule.
   */ 
  directive throws OWLException
    {
      URI id;
      OWLDataValue dLit;
      OWLIndividual indiv;
      OWLAnnotationProperty prop;
    }
    : ANNOTATION
  	  ( id = annotationPropertyID //(WS)+
        { prop = builder.addAnnotationProperty(id); 
          Object content; }
	    ( content = uriReference
  	    | indiv = individual { content = indiv; }
  	    | dLit = dataLiteral { content = dLit; }
       )
	    { OWLBuilder.AnnotationComponent annComponent =
                new OWLBuilder.AnnotationComponent(prop, content);
              builder.addOntologyAnnotationInstance(annComponent); }
      /*
       * WARNING: the following is temporarily commented out in order
       * to prevent ambiguity.
       */              
//	  | id = ontologyPropertyID //(WS)+ 
//	    ontologyID
	  )
  	  RPAREN
    | fact
    | axiom
    ;

  /**
   * Rule.
   */ 
  fact throws OWLException
    {
      URI id;
      Set individuals = new HashSet();
    }
    : individual 
    | SAME_INDIVIDUAL
	  id = individualID //(WS)+
	  { individuals.add(id); }
	  ( id = individualID { individuals.add(id); } )+
	  RPAREN
	  { builder.addSameIndividualsAxiom(individuals); }
    | DIFFERENT_INDIVIDUALS
	  id = individualID //(WS)+
	  { individuals.add(id); }
	  ( id = individualID { individuals.add(id); } )+
	  RPAREN
	  { builder.addDifferentIndividualsAxiom(individuals); }
    ;

  /**
   * Rule.
   */ 
  individual returns [OWLIndividual indiv] throws OWLException
    {
      URI id = null;
      OWLDescription descr;
      OWLBuilder.PropertyValue val;
      indiv = null;
    }
    : INDIVIDUAL
  	  ( id = individualID )? 
	  { indiv = builder.addIndividual(id); }
          ( { OWLBuilder.AnnotationComponent annComponent; }
            annComponent = annotation
	    { builder.addAnnotationInstance(indiv, annComponent); }
          )* 
  	  ( TYPE 
          descr = type
	        { builder.addDescriptionToIndividual(descr, indiv); }
        RPAREN )* 
          ( val = value { builder.addPropertyValue(indiv, val); } )*
      RPAREN
    ;

  /**
   * Rule. Assumes the first property in the value expression
   * has been already defined. 
   * If it is not a datatype property
   * it assumes it is an object property.
   * @throws UndefinedOWLPropertyException if 
   * the first property is not defined.
   */
  value returns [OWLBuilder.PropertyValue val] throws OWLException
    { 
      URI indId, propId;
      val = null; 
      OWLIndividual indiv;
      OWLDataValue dLit;
      String id, idType;
    }
    : VALUE
  	  propId = uriReference //(WS)+
            { id = propId.toString();
              idType = (String)idsTable.get(id); 
              if (idType == null) 
                  throw new UndefinedOWLPropertyException(id);
	    }
            ( { idType.equals(DATA_PROPERTY) }?
                dLit = dataLiteral
                { OWLDataProperty dProp = builder.addDataProperty(propId);  
		  val = new OWLBuilder.DataPropertyValue(dProp, dLit); }
              | { OWLObjectProperty prop = 
			builder.addObjectProperty(propId); }
                    ( indiv = individual 
	            | indId = individualID 
                      { indiv = builder.addIndividual(indId); }
                    ) { val = new OWLBuilder.ObjectPropertyValue(prop, indiv);}
            )
  	  RPAREN
    ;

  /**
   * Rule.
   */ 
  type returns [OWLDescription result] throws OWLException
    { 
      result = null; 
    }
    : result=description
    ;

  /**
   * Rule.
   */ 
  axiom throws OWLException
    : owlClass
    | enumeratedClass
    | disjointClasses
    | equivalentClasses
    | subClass
    | dataType
    | dataTypeProperty
    | objectProperty
    | annotationProperty
    | ontologyProperty
    | equivalentProperties
    | subprop
    ;

  /**
   * Rule.
   */ 
  owlClass returns [OWLClass oClass] throws OWLException
    {
      URI id;
      boolean isPartial = false; 
      OWLDescription descr;
      Set descriptions = new HashSet();
      oClass = null;
      OWLBuilder.AnnotationComponent aComponent;
    }
    : CLASS
          id = classID
          { oClass = builder.addClass(id); }
          (
	    DEPRECATED { builder.setDeprecatedObject(oClass); }
          )? 
  	  isPartial = modality
          ( aComponent = annotation
	    { builder.addAnnotationInstance(oClass, aComponent); }
          )* 
          (
            descr = description { descriptions.add(descr); }
          )* 
          { if (!descriptions.isEmpty()) {
	      if (isPartial)
	    	builder.addSuperClass(oClass, descriptions);
	      else
	    	builder.addEquivalentClass(oClass, descriptions);
            }
	  }
        RPAREN
    ;

  /**
   * Rule.
   */ 
  enumeratedClass returns [OWLClass eClass] throws OWLException
    {	
      URI id, iid;
      Set individuals = new HashSet();
      eClass = null;
    }
    : ENUMERATED_CLASS
          id = classID { eClass = builder.addClass(id); }
          (
	    DEPRECATED { builder.setDeprecatedObject(eClass); } 
          )? 
          ( { OWLBuilder.AnnotationComponent annComponent; }
            annComponent = annotation
	    { builder.addAnnotationInstance(eClass, annComponent); }
          )* 
          (
            iid = individualID { individuals.add(iid); }
          )* 
        RPAREN
      { builder.addEnumeration(eClass, individuals); }
    ;

  /**
   * Rule.
   */ 
  disjointClasses throws OWLException
    {	
      Set disjuncts = new HashSet();
      OWLDescription owlDescription;
    }
    : DISJOINT_CLASSES
          owlDescription = description { disjuncts.add(owlDescription); }
	      owlDescription = description { disjuncts.add(owlDescription); }
	      (  
            owlDescription = description { disjuncts.add(owlDescription); }
          )* 
      RPAREN
      { builder.addDisjointClassesAxiom(disjuncts); }
    ;

  /**
   * Rule.
   */ 
  equivalentClasses throws OWLException
    {	
      Set equivalents = new HashSet();
      OWLDescription owlDescription;
    }
    : EQUIVALENT_CLASSES
          owlDescription = description { equivalents.add(owlDescription); }
	  (
            owlDescription = description
            { equivalents.add(owlDescription); }
          )* 
        RPAREN
      { builder.addEquivalentClassesAxiom(equivalents); }
    ;

  /**
   * Rule.
   */ 
  subClass throws OWLException
    {	
      OWLDescription owlDescription1, owlDescription2;
    }
    : SUB_CLASS_OF
          owlDescription1 = description //(WS)+
          owlDescription2 = description 
        RPAREN
      { builder.addSubClassAxiom(owlDescription1, owlDescription2); }
    ;

  /**
   * Rule.
   */ 
  dataType returns [OWLDataType type] throws OWLException
    {	
      URI id;
      type = null;
    }
    : DATATYPE
          id = datatypeID 
          { type = builder.addDataType(id); }
	  ( 
	    DEPRECATED { builder.setDeprecatedObject(type); }
          )? 
          ( { OWLBuilder.AnnotationComponent annComponent; }
            annComponent = annotation
	    { builder.addAnnotationInstance(type, annComponent); }
          )* 
        RPAREN
    ;

  /**
   * Rule.
   */ 
  dataTypeProperty returns [OWLDataProperty prop] throws OWLException
    {	
      URI id, superId;
      prop = null;
      OWLDescription descr;
      OWLDataProperty superProp;
      OWLDataRange dRange;
    }
    : DATATYPE_PROPERTY
  	  id = datavaluedPropertyID
	  { idsTable.put(id.toString(), DATA_PROPERTY); 
            prop = builder.addDataProperty(id); }
          (
	    DEPRECATED { builder.setDeprecatedObject(prop); } 
          )? 
          ( { OWLBuilder.AnnotationComponent annComponent; }
            annComponent = annotation
	    { builder.addAnnotationInstance(prop, annComponent); }
          )* 
          ( SUPER 
                superId = datavaluedPropertyID
                { idsTable.put(superId.toString(), DATA_PROPERTY); 
                  superProp = builder.addDataProperty(superId); 
		  builder.addSuperProperty(prop, superProp); }
	      RPAREN
          )* 
          ( FUNCTIONAL
	    { builder.setDataPropertyFunctional(prop); } 
	  )?
          ( DOMAIN 
		descr = description
		{ builder.addPropertyDomain(prop, descr); }
              RPAREN )* 
  	  ( RANGE 
		dRange = dataRange
		{ builder.addDataPropertyRange(prop, dRange); }
              RPAREN )* 
  	RPAREN
    ;

  /**
   * Rule.
   */ 
  objectProperty returns [OWLObjectProperty prop] throws OWLException
    {	
      URI id, superId, inverseId;
      OWLDescription descr;
      prop = null;
      OWLObjectProperty superProp;
    }
    : OBJECT_PROPERTY
  	  id = individualvaluedPropertyID
	  { idsTable.put(id.toString(), OBJ_PROP); 
            prop = builder.addObjectProperty(id); }
	  ( DEPRECATED { builder.setDeprecatedObject(prop); } )? 
          ( { OWLBuilder.AnnotationComponent annComponent; }
            annComponent = annotation
	    { builder.addAnnotationInstance(prop, annComponent); }
          )* 
          ( SUPER
                superId = individualvaluedPropertyID 
                { idsTable.put(superId.toString(), OBJ_PROP);
		  superProp = builder.addObjectProperty(superId); 
		  builder.addSuperProperty(prop, superProp); }
	      RPAREN
          )* 
          ( INVERSE_OF
	        inverseId = individualvaluedPropertyID
		{ idsTable.put(inverseId.toString(), OBJ_PROP);
		  builder.addInverse(prop, inverseId); }
              RPAREN )? 
  	  ( SYMMETRIC
	    { builder.setPropertyType(prop, OWLBuilder.SYMMETRIC); } 
	  )? 
          ( FUNCTIONAL
	    { builder.setPropertyType(prop, OWLBuilder.FUNCTIONAL); } 
	  | INVERSE_FUNCTIONAL
	    { builder.setPropertyType(prop, OWLBuilder.INVERSE_FUNCTIONAL); } 
	  | TRANSITIVE
	    { builder.setPropertyType(prop, OWLBuilder.TRANSITIVE); }
	  )?
          ( DOMAIN
	   		descr = description
		{ builder.addPropertyDomain(prop, descr); }
              RPAREN )* 
  	  ( RANGE
		descr = description
		{ builder.addObjectPropertyRange(prop, descr); }
              RPAREN )* 
  	RPAREN
    ;

  /**
   * Rule.
   */ 
  annotationProperty returns [OWLAnnotationProperty prop] throws OWLException
    {	
      URI id;
      prop = null;
    }
    : ANNOTATION_PROPERTY
  	  id = annotationPropertyID 
          { idsTable.put(id.toString(), ANN_PROP); 
	    prop = builder.addAnnotationProperty(id); }
          ( { OWLBuilder.AnnotationComponent annComponent; }
            annComponent=annotation 
	    { builder.addAnnotationInstance(prop, annComponent); }
          )* 
  	RPAREN
    ;

  /**
   * Rule.
   */ 
  ontologyProperty throws OWLException
    {	
      URI id;
      //prop = null;
    }
    : ONTOLOGY_PROPERTY
  	  id = ontologyPropertyID 
//            { idsTable.put(id.toString(), ONTO_PROP); 
//              prop = builder.addOntologyProperty(id); }
          ( { OWLBuilder.AnnotationComponent annComponent; }
            annComponent = annotation 
	    // { builder.addAnnotationInstance(prop, annComponent); }
          )* 
  	RPAREN
    ;
  
  /**
   * Rule.
   * @throws UndefinedOWLPropertyException if none of the properties is
   * defined.
   * @throws MalformedOWLPropertyURIException if one of the properties is
   * not a well formed URI.
   */
  equivalentProperties throws OWLException
    {	
      Set ids = new HashSet();
      URI uri;
    }
    : EQUIVALENT_PROPERTIES
  	  uri = uriReference //(WS)+ 
  	  { ids.add(uri.toString()); }
          ( uri = uriReference { ids.add(uri.toString()); } )+
  	RPAREN
        { switch(inferPropertyType(ids)) {
          case DATA_PROP_INT: 
            try {
              builder
		.addEquivalentDataPropertiesAxiom(OWLBuilder.toURIs(ids)); 
            } catch (URISyntaxException e) {
		throw new MalformedOWLPropertyURIException(ids, e);
	    }
            break;
	  case OBJ_PROP_INT: 
            try {
              builder
		.addEquivalentObjectPropertiesAxiom(OWLBuilder.toURIs(ids));
            } catch (URISyntaxException e) {
		throw new MalformedOWLPropertyURIException(ids, e);
	    }
	    break;
	  }
        }
    ;

  /**
   * Rule.
   * @throws UndefinedOWLPropertyException if neither of the properties is
   * defined.
   * @throws MalformedOWLPropertyURIException if one of the two properties is
   * not a well formed URI.
   */
  subprop throws OWLException
    { URI subUri, supUri; }
    : SUB_PROPERTY_OF
  	  subUri = uriReference //(WS)+ 
  	  supUri = uriReference 
  	RPAREN
        { Set ids = new HashSet();
	  ids.add(subUri.toString());
	  ids.add(supUri.toString());	  
          switch(inferPropertyType(ids)) {
          case DATA_PROP_INT: 
	    builder.addDataSubPropertyAxiom(subUri, supUri);
            break;
	  case OBJ_PROP_INT: 
	    builder.addObjectSubPropertyAxiom(subUri, supUri);
	    break;
	  }
        }
    ;

  /**
   * Rule.
   */ 
  annotation returns [OWLBuilder.AnnotationComponent aComponent] 
	throws OWLException
    {
      URI id; 
      Object content;
      OWLAnnotationProperty annProp;
      aComponent = null;
    }
    : ANNOTATION_LOWER
	  id = annotationPropertyID // (WS)+
	  { annProp = builder.addAnnotationProperty(id); } 
	  ( content = uriReference
  	  | content = dataLiteral 
  	  | content = individual )
  	RPAREN      
        { aComponent = new OWLBuilder.AnnotationComponent(annProp, content); }
    ;

  /**
   * Rule. Returns <code>true</code> is the modality is <code>partial</code>.
   */ 
  modality returns [boolean isPartial]
    { isPartial = false; }
    : COMPLETE
    | PARTIAL { isPartial = true; } 
    ;

  /**
   * Invoked by {@link AbstractOWLParser#parseDescription(Reader)}.
   * Returns the OWLDescription corresponding to the description in the Reader
   * using <code>newBuilder</code> and <code>newIdsTable</code>.
   * @param newBuilder the OWLBuilder used to build the description.
   * @param newIdsTable the table of ids used to disambiguate
   * the property types.
   */
  externalDescription 
	[OWLBuilder newBuilder, Map newIdsTable, Map newNamespaceTable] 
	returns [OWLDescription descr] 
	throws OWLException
    {
      builder = newBuilder;
      idsTable = newIdsTable;
      namespaceTable = newNamespaceTable;
      descr = null;
    }
    : descr=description
    ;

  /**
   * Rule.
   */ 
  description returns [OWLDescription result] throws OWLException
    { 
      result = null; 
      URI id;
      OWLRestriction restr;
      OWLDescription descr;
      Set descriptions = new HashSet();
      Set individuals = new HashSet();
    }
    : id = classID
      { result = builder.getClass(id); }
    | result = restriction 
    | UNION_OF
	  ( descr = description { descriptions.add(descr); } )* 
	RPAREN
	{ result = builder.unionOf(descriptions); }
    | INTERSECTION_OF
	  ( descr = description { descriptions.add(descr); } )* 
	RPAREN
	{ result = builder.intersectionOf(descriptions); }
    | COMPLEMENT_OF
	  descr = description
	RPAREN
        { result = builder.complementOf(descr); }
    | ONE_OF 
	  ( id = individualID { individuals.add(id); } )* 
	RPAREN
	{ result = builder.oneOf(individuals); }
    ;

  /**
   * Rule.
   * Assumes the first property in the restriction is defined in the ontology.
   * If it is not a datatype property
   * it assumes it is an object property.
   * @throws UndefinedOWLPropertyException if the property is not defined.
   */
  restriction returns [OWLRestriction result] throws OWLException
    {	
      result = null; 
      URI id;
      OWLBuilder.RestrictionComponent restr;
      OWLDataProperty dataProp;
      OWLObjectProperty objectProp;
      String idString, idType;
    }
    : RESTRICTION
  	  id = uriReference
            { idString = id.toString();
              idType = (String)idsTable.get(idString); 
              if (idType == null) 
                  throw new UndefinedOWLPropertyException(idString);
	    }
            ( { idType
                .equals(DATA_PROPERTY) }?

  	        { dataProp = builder.addDataProperty(id); }
	        ( restr = dataRestrictionComponent
	          { result = builder.getRestriction(dataProp, restr); } 
	        )+
	      | { objectProp = builder.addObjectProperty(id); }
                ( restr = individualRestrictionComponent
	          { result = builder.getRestriction(objectProp, restr); } 
	        )+
	    )
        RPAREN
    ;

  /**
   * Rule.
   */ 
  dataRestrictionComponent 
    returns [OWLBuilder.RestrictionComponent restr] 
	throws OWLException
    { 
      restr = null; 
      OWLDataRange dRange;
    } 
    : ALL_VALUES_FROM
          dRange = dataRange
	  { restr = new OWLBuilder.DataRangeComponent
                                (dRange, OWLBuilder.DataRangeComponent.ALL); }
        RPAREN
    | SOME_VALUES_FROM
          dRange = dataRange
	  { restr = new OWLBuilder.DataRangeComponent
                                (dRange, OWLBuilder.DataRangeComponent.SOME); }
        RPAREN
    | VALUE
          { OWLDataValue dLit; }
          dLit = dataLiteral
          { restr = new OWLBuilder.DataLiteralValueComponent(dLit); }
        RPAREN
    | restr = cardinality
    ;

  /**
   * Rule.
   */ 
  individualRestrictionComponent 
    returns [OWLBuilder.RestrictionComponent restr] 
	throws OWLException
    { 
      restr = null; 
      OWLDescription descr;
      URI id;
    }
    : ALL_VALUES_FROM descr = description RPAREN
      { restr = builder.createDescriptionComponent
		      (descr, OWLBuilder.DescriptionComponent.ALL); }
    | SOME_VALUES_FROM descr = description RPAREN
        { restr = builder.createDescriptionComponent
		    (descr, OWLBuilder.DescriptionComponent.SOME); }
    | VALUE id = individualID RPAREN
      { restr = new OWLBuilder.IndividualValueComponent(id); }
    | restr = cardinality
    ;

  /**
   * Rule.
   */ 
  cardinality returns [OWLBuilder.CardinalityComponent card]
    { 
      card = null;
    }
    : ( MIN_CARDINALITY
	{ card = builder.createCardinalityComponent
		 (OWLBuilder.CardinalityComponent.MIN); }
      | MAX_CARDINALITY
	{ card = builder.createCardinalityComponent
		 (OWLBuilder.CardinalityComponent.MAX); }
      | CARDINALITY
	{ card = builder.createCardinalityComponent
		 (OWLBuilder.CardinalityComponent.EQ); }
      )
        c:CARD
      { card.setCardinality(removeTail(c.getText())); }
    ;

  /**
   * Rule.
   */ 
  dataRange returns [OWLDataRange dataRange] throws OWLException
    { dataRange = null; }
    : { URI id; } 
      id = datatypeID
      { dataRange = builder.getConcreteDataType(id); }
    | RDFSLITERAL
      { dataRange = builder.getConcreteDataType(RDFS_LIT_URI); }
    | { Set literals = new HashSet(); OWLDataValue literal; }
      ONE_OF
	  ( literal = dataLiteral { literals.add(literal); } )* 
	  { dataRange = builder.getDataEnumeration(literals); }
	RPAREN
    ;

  /**
   * Rule.
   */ 
  dataLiteral returns [OWLDataValue literal] throws OWLException
    { literal = null; }
    : literal = datatypeString 
    ;

  /**
   * Rule.
   */ 
  datatypeString returns [OWLDataValue literal] throws OWLException
    { literal = null; String val; URI uri = null; String lang = null; }
    : q:QUOTED_STRING 
      { val = removeHeadAndTail(q.getText()); }
      ( DOUBLE_CARET 
        uri = uriReference
      | AT l:LANGUAGE { lang = l.getText(); }
      )?
      { literal = builder.getConcreteData(uri, lang, val); }
    ;

  /**
   * Rule.
   */ 
  datatypeID returns [URI uri] 
	throws MalformedOWLURIException 
    { uri = null; }
    : uri = uriReference 
    ;

  /**
   * Rule.
   */ 
  classID returns [URI uri] 
	throws MalformedOWLURIException 
    { uri = null; }
    : uri = uriReference 
    ;

  /**
   * Rule.
   */ 
  individualID returns [URI uri] 
	throws MalformedOWLURIException 
    { uri = null; }
    : uri = uriReference 
    ;

  /**
   * Rule.
   */ 
  ontologyID returns [URI uri] 
	throws MalformedOWLURIException 
    { uri = null; }
    : uri = uriReference 
    ;

  /**
   * Rule.
   */ 
  datavaluedPropertyID returns [URI uri] 
	throws MalformedOWLURIException 
    { uri = null; }
    : uri = uriReference 
    ;

  /**
   * Rule.
   */ 
  individualvaluedPropertyID returns [URI uri]
	throws MalformedOWLURIException  
    { uri = null; }
    : uri = uriReference 
    ;

  /**
   * Rule.
   */ 
  annotationPropertyID returns [URI uri] 
	throws MalformedOWLURIException  
    { uri = null; }
    : uri = uriReference 
    ;

  /**
   * Rule.
   */ 
  ontologyPropertyID returns [URI uri] 
	throws MalformedOWLURIException  
    { uri = null; }
    : uri = uriReference 
    ;

  /**
   * Rule.
   */ 
  uriReference returns [URI uri] 
	throws MalformedOWLURIException  
    { 
      uri = null; 
      String id;
    } 
    : ( u:URI_ID 
        { id = removeHeadAndTail(u.getText()); }
      | { String[] qn; }
        qn=qname
        { id = namespaceTable.get(qn[0]) + qn[1]; }
      )
      { uri = createURI(id); }
    ;

  /**
   * Rule.
   */ 
  qname returns [String[] s]
    { 
       s = null; 
    }
    : p:REF_PREFIX 
      i:LOCAL_NAME
      { s = new String[]{removeTail(p.getText()), i.getText()}; }
    ;
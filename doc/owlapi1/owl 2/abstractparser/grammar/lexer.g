/*
 * Copyright (C) 2003 The University of Manchester 
 *
 * Modifications to the initial code base are copyright of their
 * respective authors, or their employers as appropriate.  Authorship
 * of the modifications may be determined from the ChangeLog placed at
 * the end of this file.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA.
 *
 ****************************************************************
 * Source code information
 * -----------------------
 * Filename           $RCSfile: lexer.g,v $
 * Revision           $Revision: 1.3 $
 * Release status     $State: Exp $
 * Last modified on   $Date: 2004/02/19 15:16:08 $
 *               by   $Author: dturi $
 ****************************************************************/

header {
package org.semanticweb.owl.io.abstract_syntax; 
}


/**  
 * Lexer for 
 * <a href="http://owl.man.ac.uk/2003/concrete/latest/">OWL abstract 
 * syntax</a>.
 *
 * <p>
 * Generated by ANTLR from file <code>lexer.g</code>.
 * </p>
 *
 * @author Daniele Turi, Olga Caprotti
 */
class AbstractOWLLexer extends Lexer;

  options {
    exportVocab = OWL;
    k = 2; //need distinguishing between eg Annotation and AnnotationProperty
    // testLiterals=false;    // don't automatically test for literals
    charVocabulary='\u0003'..'\uFFFE'; 
          // Note that \uFFFF is -1 which is the current encoding of EOF.
  }

	EQUAL: '=';
	UNDERSCORE: '_';
	PLUS: '+';
	DASH: '-';
	QUOTE: '"';
	AT: '@';
	COLON: ':';
	LPAREN: '(';
	RPAREN: ')';
	LANGLE: '<';
	RANGLE: '>';
	DOUBLE_CARET: "^^";
  	
  	WS : ( ' '
     | '\r' '\n'
     | '\n'
     | '\t'
       ) { $setType(Token.SKIP); }
     ;
     
  	/**
  	 * Trick to enforce an order on keyword recognition 
  	 * (copied from Jena's n3.g).
  	 */
  	ORDER_ENFORCING_DUMMY_TOKEN :
  		(NAMESPACE) => NAMESPACE { $setType(NAMESPACE); }
      |	(ONTOLOGY_PROPERTY) => ONTOLOGY_PROPERTY 
				{ $setType(ONTOLOGY_PROPERTY); } 
      |	(ONTOLOGY) => ONTOLOGY { $setType(ONTOLOGY); } 
      |	(ANNOTATION_PROPERTY) => ANNOTATION_PROPERTY 
				{ $setType(ANNOTATION_PROPERTY); } 
      |	(ANNOTATION) => ANNOTATION { $setType(ANNOTATION); } 
      | (CLASS) => CLASS { $setType(CLASS); }
      | (ENUMERATED_CLASS) => ENUMERATED_CLASS { $setType(ENUMERATED_CLASS); }
      | (DISJOINT_CLASSES) => DISJOINT_CLASSES { $setType(DISJOINT_CLASSES); }
      | (EQUIVALENT_CLASSES) => EQUIVALENT_CLASSES 
				{ $setType(EQUIVALENT_CLASSES); }
      | (SUB_CLASS_OF) => SUB_CLASS_OF { $setType(SUB_CLASS_OF); }
      | (DATATYPE_PROPERTY) => DATATYPE_PROPERTY { $setType(DATATYPE_PROPERTY); }
      | (DATATYPE) => DATATYPE { $setType(DATATYPE); }
      | (SUPER) => SUPER { $setType(SUPER); }
      | (DOMAIN) => DOMAIN { $setType(DOMAIN); }
      | (RANGE) => RANGE { $setType(RANGE); }
      | (OBJECT_PROPERTY) => OBJECT_PROPERTY { $setType(OBJECT_PROPERTY); }
      | (INVERSE_OF) => INVERSE_OF { $setType(INVERSE_OF); }
      | (SYMMETRIC) => SYMMETRIC { $setType(SYMMETRIC); }
      | (FUNCTIONAL) => FUNCTIONAL { $setType(FUNCTIONAL); }
      | (INVERSE_FUNCTIONAL) => INVERSE_FUNCTIONAL { $setType(INVERSE_FUNCTIONAL); }
      | (TRANSITIVE) => TRANSITIVE { $setType(TRANSITIVE); }
      | (EQUIVALENT_PROPERTIES) => EQUIVALENT_PROPERTIES { $setType(EQUIVALENT_PROPERTIES); }
      | (SUB_PROPERTY_OF) => SUB_PROPERTY_OF { $setType(SUB_PROPERTY_OF); }
      | (RESTRICTION) => RESTRICTION { $setType(RESTRICTION); }
      | (UNION_OF) => UNION_OF { $setType(UNION_OF); }
      | (INTERSECTION_OF) => INTERSECTION_OF { $setType(INTERSECTION_OF); }
      | (COMPLEMENT_OF) => COMPLEMENT_OF { $setType(COMPLEMENT_OF); }
      | (ONE_OF) => ONE_OF { $setType(ONE_OF); }
      | (ALL_VALUES_FROM) => ALL_VALUES_FROM { $setType(ALL_VALUES_FROM); }
      | (SOME_VALUES_FROM) => SOME_VALUES_FROM { $setType(SOME_VALUES_FROM); }
      | (VALUE) => VALUE { $setType(VALUE); }
      | (MIN_CARDINALITY) => MIN_CARDINALITY { $setType(MIN_CARDINALITY); }
      | (MAX_CARDINALITY) => MAX_CARDINALITY { $setType(MAX_CARDINALITY); }
      | (CARDINALITY) => CARDINALITY { $setType(CARDINALITY); }
      | (SAME_INDIVIDUAL) => SAME_INDIVIDUAL { $setType(SAME_INDIVIDUAL); }
      | (DIFFERENT_INDIVIDUALS) => DIFFERENT_INDIVIDUALS { $setType(DIFFERENT_INDIVIDUALS); }
      | (INDIVIDUAL) => INDIVIDUAL { $setType(INDIVIDUAL); }
      | (TYPE) => TYPE { $setType(TYPE); }
      | (ANNOTATION_LOWER) => ANNOTATION_LOWER { $setType(ANNOTATION_LOWER); }
      | (RDFSLITERAL) => RDFSLITERAL { $setType(RDFSLITERAL); }
	  | (DEPRECATED (WS)+) => DEPRECATED { $setType(DEPRECATED); }
	  | (PARTIAL RPAREN) => PARTIAL { $setType(PARTIAL); }
      | (PARTIAL (WS)+) => PARTIAL { $setType(PARTIAL); }
   	  | (COMPLETE (WS)+) => COMPLETE { $setType(COMPLETE); }
      | (PREFIX (WS)* EQUAL) => PREFIX { $setType(PREFIX); }
      | (REF_PREFIX) => REF_PREFIX { $setType(REF_PREFIX); }
      | (LANGUAGE) => LANGUAGE { $setType(LANGUAGE); }
      | (LOCAL_NAME) => LOCAL_NAME { $setType(LOCAL_NAME); }
      | (CARD) => CARD { $setType(CARD); }
      ;

    protected NAMESPACE : "Namespace" (WS)* LPAREN;
    protected ONTOLOGY_PROPERTY: "OntologyProperty" (WS)* LPAREN;
    protected ONTOLOGY: "Ontology" (WS)* LPAREN;
    protected ANNOTATION_PROPERTY: "AnnotationProperty" (WS)* LPAREN;
    protected ANNOTATION: "Annotation" (WS)* LPAREN;
    protected CLASS: "Class" (WS)* LPAREN;
  protected ENUMERATED_CLASS: "EnumeratedClass" (WS)* LPAREN;
  protected DISJOINT_CLASSES: "DisjointClasses" (WS)* LPAREN;
  protected EQUIVALENT_CLASSES: "EquivalentClasses" (WS)* LPAREN;
  protected SUB_CLASS_OF: "SubClassOf" (WS)* LPAREN;
  protected DATATYPE_PROPERTY: "DatatypeProperty" (WS)* LPAREN;
  protected DATATYPE: "Datatype" (WS)* LPAREN;
  protected SUPER: "super" (WS)* LPAREN;
  protected DOMAIN: "domain" (WS)* LPAREN;
  protected RANGE: "range" (WS)* LPAREN;
  protected OBJECT_PROPERTY: "ObjectProperty" (WS)* LPAREN;
  protected INVERSE_OF: "inverseOf" (WS)* LPAREN;
  protected SYMMETRIC: "Symmetric";
  protected FUNCTIONAL: "Functional";
  protected INVERSE_FUNCTIONAL: "InverseFunctional";
  protected TRANSITIVE: "Transitive";
  protected EQUIVALENT_PROPERTIES: "EquivalentProperties" (WS)* LPAREN;
  protected SUB_PROPERTY_OF: "SubPropertyOf" (WS)* LPAREN;
  protected RESTRICTION: "restriction" (WS)* LPAREN;
  protected UNION_OF: "unionOf" (WS)* LPAREN;
  protected INTERSECTION_OF: "intersectionOf" (WS)* LPAREN;
  protected COMPLEMENT_OF: "complementOf" (WS)* LPAREN;
  protected ONE_OF: "oneOf" (WS)* LPAREN;
  protected ALL_VALUES_FROM: "allValuesFrom" (WS)* LPAREN;
  protected SOME_VALUES_FROM: "someValuesFrom" (WS)* LPAREN;
  protected VALUE: "value" (WS)* LPAREN;
  protected MIN_CARDINALITY: "minCardinality" (WS)* LPAREN;
  protected MAX_CARDINALITY: "maxCardinality" (WS)* LPAREN;
  protected CARDINALITY: "cardinality" (WS)* LPAREN;
  protected SAME_INDIVIDUAL: "SameIndividual" (WS)* LPAREN;
  protected DIFFERENT_INDIVIDUALS: "DifferentIndividuals" (WS)* LPAREN;
  protected INDIVIDUAL: "Individual" (WS)* LPAREN;
  protected TYPE: "type" (WS)* LPAREN;
  protected ANNOTATION_LOWER: "annotation" (WS)* LPAREN;
  protected RDFSLITERAL: "Literal";
  protected DEPRECATED: "Deprecated";
     protected PARTIAL: "partial";
     protected COMPLETE: "complete";
     protected CARD: (ARABIC_DIGIT)+ (WS)* RPAREN;


  URI_ID: LANGLE 
	  ("urn:"|"file:"|"http://") 
          ( ~('\n'|'\r'|'\t'|' '|')'|'>') )*
	  RANGLE;

  protected LOWER_ROMAN: '\u0041'..'\u005a';

  protected LETTER: 
	  LOWER_ROMAN
	| '\u0061'..'\u007a'
	| '\u0e81'..'\u0e82'
	| '\u0e84'
	| '\u0e87'..'\u0e88'
	| '\u0e8a'
	| '\u0e8d'
	| '\u0e94'..'\u0e97'
	| '\u0e99'..'\u0e9f'
	| '\u0ea1'..'\u0ea3'
	| '\u0ea5'
	| '\u0ea7'
	| '\u0eaa'..'\u0eab'
	| '\u0ead'..'\u0eb0'
	| '\u0eb2'..'\u0eb3'
	| '\u0ebd'
	| '\u0ec0'..'\u0ec4'
	| '\u0ec6'
	| '\u0edc'..'\u0edd'
	| '\u0f00'
	| '\u0f40'..'\u0f47'
	| '\u0f49'..'\u0f6a'
	| '\u0f88'..'\u0f8b'
	| '\u1000'..'\u1021'
	| '\u1023'..'\u1027'
	| '\u1029'..'\u102a'
	| '\u1050'..'\u1055'
	| '\u10a0'..'\u10c5'
	| '\u10d0'..'\u10f6'
	| '\u1100'..'\u1159'
	| '\u115f'..'\u11a2'
	| '\u11a8'..'\u11f9'
	| '\u1200'..'\u1206'
	| '\u1208'..'\u1246'
	| '\u1248'
	| '\u124a'..'\u124d'
	| '\u1250'..'\u1256'
	| '\u1258'
	| '\u125a'..'\u125d'
	| '\u1260'..'\u1286'
	| '\u1288'
	| '\u128a'..'\u128d'
	| '\u1290'..'\u12ae'
	| '\u12b0'
	| '\u12b2'..'\u12b5'
	| '\u12b8'..'\u12be'
	| '\u12c0'
	| '\u12c2'..'\u12c5'
	| '\u12c8'..'\u12ce'
	| '\u12d0'..'\u12d6'
	| '\u12d8'..'\u12ee'
	| '\u12f0'..'\u130e'
	| '\u1310'
	| '\u1312'..'\u1315'
	| '\u1318'..'\u131e'
	| '\u1320'..'\u1346'
	| '\u1348'..'\u135a'
	| '\u13a0'..'\u13f4'
	| '\u1401'..'\u166c'
	| '\u166f'..'\u1676'
	| '\u1681'..'\u169a'
	| '\u16a0'..'\u16ea'
	| '\u1780'..'\u17b3'
	| '\u1820'..'\u1877'
	| '\u1880'..'\u18a8'
	| '\u1e00'..'\u1e9b'
	| '\u1ea0'..'\u1ef9'
	| '\u1f00'..'\u1f15'
	| '\u1f18'..'\u1f1d'
	| '\u1f20'..'\u1f45'
	| '\u1f48'..'\u1f4d'
	| '\u1f50'..'\u1f57'
	| '\u1f59'
	| '\u1f5b'
	| '\u1f5d'
	| '\u1f5f'..'\u1f7d'
	| '\u1f80'..'\u1fb4'
	| '\u1fb6'..'\u1fbc'
	| '\u1fbe'
	| '\u1fc2'..'\u1fc4'
	| '\u1fc6'..'\u1fcc'
	| '\u1fd0'..'\u1fd3'
	| '\u1fd6'..'\u1fdb'
	| '\u1fe0'..'\u1fec'
	| '\u1ff2'..'\u1ff4'
	| '\u1ff6'..'\u1ffc'
	| '\u207f'
	| '\u2102'
	| '\u2107'
	| '\u210a'..'\u2113'
	| '\u2115'
	| '\u2119'..'\u211d'
	| '\u2124'
	| '\u2126'
	| '\u2128'
	| '\u212a'..'\u212d'
	| '\u212f'..'\u2131'
	| '\u2133'..'\u2139'
	| '\u3005'..'\u3006'
	| '\u3031'..'\u3035'
	| '\u3041'..'\u3094'
	| '\u309d'..'\u309e'
	| '\u30a1'..'\u30fa'
	| '\u30fc'..'\u30fe'
	| '\u3105'..'\u312c'
	| '\u3131'..'\u318e'
	| '\u31a0'..'\u31b7'
	| '\u3400'..'\u4db5'
	| '\u4e00'..'\u9fa5'
	| '\ua000'..'\ua48c'
	| '\uac00'..'\ud7a3'
	| '\uf900'..'\ufa2d'
	| '\ufb00'..'\ufb06'
	| '\ufb13'..'\ufb17'
	| '\ufb1d'
	| '\ufb1f'..'\ufb28'
	| '\ufb2a'..'\ufb36'
	| '\ufb38'..'\ufb3c'
	| '\ufb3e'
	| '\ufb40'..'\ufb41'
	| '\ufb43'..'\ufb44'
	| '\ufb46'..'\ufbb1'
	| '\ufbd3'..'\ufd3d'
	| '\ufd50'..'\ufd8f'
	| '\ufd92'..'\ufdc7'
	| '\ufdf0'..'\ufdfb'
	| '\ufe70'..'\ufe72'
	| '\ufe74'
	| '\ufe76'..'\ufefc'
	| '\uff21'..'\uff3a'
	| '\uff41'..'\uff5a'
	| '\uff66'..'\uffbe'
	| '\uffc2'..'\uffc7'
	| '\uffca'..'\uffcf'
	| '\uffd2'..'\uffd7'
	| '\uffda'..'\uffdc'
	;

  protected ARABIC_DIGIT : '0'..'9';

  protected DIGIT_NON_ARABIC : '\u0660'..'\u0669'
	| '\u06f0'..'\u06f9'
	| '\u0966'..'\u096f'
	| '\u09e6'..'\u09ef'
	| '\u0a66'..'\u0a6f'
	| '\u0ae6'..'\u0aef'
	| '\u0b66'..'\u0b6f'
	| '\u0be7'..'\u0bef'
	| '\u0c66'..'\u0c6f'
	| '\u0ce6'..'\u0cef'
	| '\u0d66'..'\u0d6f'
	| '\u0e50'..'\u0e59'
	| '\u0ed0'..'\u0ed9'
	| '\u0f20'..'\u0f29'
	| '\u1040'..'\u1049'
	| '\u1369'..'\u1371'
	| '\u17e0'..'\u17e9'
	| '\u1810'..'\u1819'
	| '\uff10'..'\uff19'
	;

  /* Uses part of a rule in http://www.antlr.org/grammar/java/java.g */
  QUOTED_STRING	
	:	'"' (ESC|~('"'|'\\'))* '"'
	;


  /* Uses part of a rule in http://www.antlr.org/grammar/java/java.g */
  // escape sequence -- note that this is protected; it can only be called
  //   from another lexer rule -- it will not ever directly return a token to
  //   the parser
  protected
  ESC
	:	'\\'
		(	'"'
		|	'\''
		|	'\\'
		)
	;

  /* Copied from http://www.antlr.org/grammar/java/java.g */
  SL_COMMENT 
	:	"//"
		(~('\n'|'\r'))* ('\n'|'\r'('\n')?)
		{$setType(Token.SKIP);}
	;

  /* Copied from http://www.antlr.org/grammar/java/java.g */
  ML_COMMENT
	:	"/*"
		(	
  /*	'\r' '\n' can be matched in one alternative or by matching
	'\r' in one iteration and '\n' in another.  I am trying to
	handle any flavor of newline that comes in, but the language
	that allows both "\r\n" and "\r" and "\n" to all be valid
	newline is ambiguous.  Consequently, the resulting grammar
	must be ambiguous.  I'm shutting this warning off.
   */
		options {
			generateAmbigWarnings=false;
		}
		:
			{ LA(2)!='/' }? '*'
		|	'\r' '\n'		
		|	'\r'			
		|	'\n'			
		|	~('*'|'\n'|'\r')
		)*
		"*/"
		{$setType(Token.SKIP);}
	;

	protected REF_PREFIX : ( LETTER )+ COLON ;

	protected PREFIX : ( LETTER )+;
	
	protected LANGUAGE : ( LETTER )+ 
		( DASH ( LETTER | ARABIC_DIGIT | d:DIGIT_NON_ARABIC )+ )+;
  
  protected LOCAL_NAME 
     : 
       LETTER 
       (LETTER | ARABIC_DIGIT | DIGIT_NON_ARABIC | UNDERSCORE )*;

  /* Copied from http://www.antlr.org/grammar/java/java.g */
  // a dummy rule to force vocabulary to be all characters,
  // except special ones that ANTLR uses internally (0 to 2)
  protected VOCAB: '\3'..'\ufffe';



% !TEX encoding = ISO-8859-1
%\chapter{Normalização para o método das conexões}
%\label{ch:normalizacaoparaometododeconexoes}

O método das conexões proposto por W. Bibel \cite{bibel:1982} é um método para prova automática de teoremas descritos em lógica de primeira ordem \cite{bibel:1993}. Um dos trabalhos recentes de Freitas et al \cite{Freitas:2010} foi a extenção desse método para lógica de descrição $ALC$.

O artigo intitulado \textit{A Connection Method for Reasoning with the Description Logic ALC} \cite{Freitas:2010} propõe algoritmos tanto para o método, quanto para a normalização que precisa ser feita na base de conhecimento para que seja possível a representação necessária para o método das conexões usando apenas uma matriz. 

O objetivo deste trabalho é implementar algum algoritmo de normalização para o método das conexões como os citados no texto de Freitas et al. Dois algoritmos foram propostos com esse objetivo \cite{Freitas:2010}; o primeiro utiliza-se de uma tabela com nove regras que devem ser aplicadas à base de conhecimento a fim de obter a forma normal positiva. O segundo, intitulado "\textit{A more complex and efficient normalization}" não cria novos símbolos durante a sua execução, fazendo-o mais eficiente que o primeiro em relação ao uso de memória.

No cronograma deste trabalho estava prevista a implementação desse segundo algoritmo, porém, ao decorrer do desenvolvimento, propomos um terceiro algoritmo que é ainda mais eficiente em relação ao uso de memória, ele é linear em relação à quantidade de impurezas na base, enquanto que o "\textit{A more complex and efficient normalization}" é quadrático. O restante desse capítulo se dedicará a dar definições para o entendimento do último algoritmo citado e também descreverá a sua implementação.

\subsection{Tradução de ontologias $ALC$ para forma normal disjuntiva}

%Para que o leitor consiga entender melhor os algoritmos de tradução, alguns conceitos precisam ser fixados. 

Métodos diretos como o método das conexões são formulados para provar que uma fórmula ou um conjunto de fórmulas é um teorema, sse cada interpretação gerada é uma tautologia. Tautologias normalmente tomam a forma $L \lor \neg L$, nesse caso, a fórmula precisa estar na Forma Normal Disjuntiva (ou, do inglês, Disjunctive Normal Form - DNF).

\begin{definicao}[Forma Normal Disjuntiva, cláusula]
 Uma fórmula em DNF é uma conjunção de disjunções. Ou seja, tomam a forma:

\begin{center}
$\bigcup \limits_{i=1}^{n} C_i$ , ou, $C_1 \lor ... \lor C_n$.
\end{center}

onde cada $C_i$ é uma \textit{cláusula}. Uma cláusula é uma conjunção de literais. Ou seja, tomam a forma:

\begin{center}
$\bigcap \limits_{j=1}^m L_{i, j}$ , ou, $L_{i, 1} \land ... \land L_{i, m}$ , também representado por $\{ L_{i, 1}, ..., L_{i, m} \}$
\end{center}

onde cada $L_{i, j}$ é um literal, resultando na fórmula:

\begin{center}
$\bigcap \limits_{i=1}^n \bigcup \limits_{j=1}^m L_{i, j}$ , ou, $(L_{1,1} \land ... \land L_{1,m}) \lor (L_{n, 1} \land ... \land L_{n, m})$
\end{center}

podendo ser chamada também de forma causal disjuntiva, representada por: 

\begin{center}
$\{\{ (L_{1, 1}, ..., L_{1, m}\}, ..., \{L_{n, 1}, ..., L_{n, m} \}\}$
\end{center}

\end{definicao}

A definição acima é a definição herdada da lógica de primeira ordem, para ser válida também para a lógica de descrição o conceito de conjunções e disjunções deve ser estendido.

\begin{definicao}[Conjunção ALC]
Uma conjunção ALC é um literal $L$, uma conjunção $(E_0 \land , ..., \land E_n)$, ou uma restrição existencial $\exists x.E$, onde $E$ é uma expressão qualquer em lógica de descrição.
\end{definicao}

\begin{definicao}[Disjunção ALC]
Uma disjunção ALC é um literal $L$, uma disjunção $(E_0 \lor , ..., \lor E_n)$, ou uma restrição de valor $\forall x.E$, onde $E$ é uma expressão qualquer em lógica de descrição.
\end{definicao}

\begin{definicao}[Conjunção ALC pura, Conjunção ALC não pura]
Uma conjunção ALC pura é uma conjunção ALC que na forma normal negada não contém restrições de valor ($\forall x.E$) e também não contém disjunções $(E \lor , ..., \lor E)$. O conjunto de conjunções ALC puras é representado por $\hat{C}$. Uma conjunção ALC não pura é uma conjunção ALC que não é pura.
\end{definicao}

\begin{definicao}[Disjunção ALC pura, Disjunção ALC não pura]
Uma disjunção ALC pura é uma disjunção ALC que na forma normal negada não contém restrições existenciais ($\exists x.E$) e também não contém conjunções $(E \land , ..., \land E)$. O conjunto de disjunções ALC puras é representado por $\check{D}$. Uma disjunção ALC não pura é uma disjunção ALC que não é pura.
\end{definicao}

\begin{definicao}[Impureza em uma expressão não pura]
Impureza em expressões ALC não puras são conjunções em disjunções não puras ou disjunções em conjunções não puras. O conjunto de impurezas é chamado de \text{conjunto de impurezas ALC} e é representado por $I$.
\end{definicao}

\begin{definicao}[Forma Normal Positiva]
Um axioma ALC está na Forma Normal Positiva sse ele está em uma das seguintes formas: 

\begin{center}
i) $A \sqsubseteq \hat{C}$ \\
ii) $\check{D} \sqsubseteq A$ \\
iii) $\hat{C} \sqsubseteq \check{D}$ \\ 
\end{center}

onde A é um conceito atômico,  $\hat{C}$ é uma conjunção ALC pura, $\check{D}$ é uma disjunção ALC pura.

\end{definicao}

O método das conexões utiliza matrizes para realizar provas de teoremas. No início deste trabalho, ainda não era possível fazer as provas com matrizes aninhadas, ou seja, havia sempre a necessidade de normalizar a base de conhecimento na forma normal positiva (definição 7). No entanto, Jens Otten em um trabalho entitulado \textit{A Non-clausal Connection Calculus} \cite{Otten:2011} mostrou como aplicar o método das conexões sem o passo da normalização. Apesar da recente evolucão do método, para o objetivo deste trabalho, ainda é necessário fazer a normalização, já que para lógica de descrição, o método ainda não foi modificado para usar matrizes aninhadas.

A próxima seção deste artigo descreve o algoritmo que propomos para a normalização para a forma normal positiva.


\subsubsection{Algoritmo Proposto}

%Esta seção da monografia descreve a implementação realizada neste trabalho.

O método das conexões é um método direto, ou seja, uma consulta à base de conhecimento verifica se uma fórmla é uma tautologia e toma a forma $KB \rightarrow \alpha$, onde $\alpha$ é um axioma e $KB$ (\textit{Knowledge base}) é da forma $\bigcap \limits_{i=1}^{n} A_i$, onde $A_i$ também é um axioma. Expandindo a fórmula $\neg KB \lor \alpha$, temos:

$\neg \bigcap \limits_{i=1}^{n} A_i \lor \alpha$ [ou, $\neg (A_1 \land ... \land A_n) \lor \alpha$], que pode ser transformada para:

$\bigcup \limits_{i=1}^{n} \neg A_i \lor \alpha$ [ou, $\neg A_1 \lor ... \lor \neg A_n \lor \alpha$]

%, e $\alpha$ ainda é transformada para $\neg \neg\alpha$ para que as regras de normalização também se apliquem a ela, ficando:

%$\bigcup \limits_{i=1}^{n} \neg A_i \lor \neg \neg \alpha$ [ou, em uma forma por extenso, $\neg A_1 \lor ... \lor \neg A_n \lor \neg \neg \alpha$]

Cada $A_i$ ou $\alpha$ precisa estar na forma normal positiva, ou seja, precisa estar em uma das formas: i) $A \sqsubseteq \hat{C}$, ii) $\check{D} \sqsubseteq A$, ou, iii) $\hat{C} \sqsubseteq \check{D}$, onde $A$ é um conceito, $\hat{C}$ é uma conjunção pura e $\check{D}$ é uma disjunção pura.

O primeiro passo do algoritmo é a separação de axiomas de equivalência. Os axiomas de equivalência serão substituídos por dois axiomas de inclusão, e.g., $(A \equiv B \rightarrow A \sqsubseteq B \land B \sqsubseteq A)$.
%
%\begin{algorithm}
%\caption{Normalize-Ontology(O)}
%\label{alg:normalizeontology}
%\begin{algorithmic}[1]
%\REQUIRE O: ontologia em lógica de descrições $ALC$
%\FORALL [A, B são expressões, $S_I$ é o conjunto dos axiomas de inclusão pertencentes a O]{$A \sqsubseteq B \in S_I$}
%\STATE Normalize-Axiom ($A \sqsubseteq B$)
%\ENDFOR
%\FORALL [A, B são expressões, $S_{EQ}$ é o conjunto dos axiomas de equivalência pertencentes a O]{$A \equiv B \in S_{EQ}$}
%\STATE Normalize-Axiom ($A \sqsubseteq B$)
%\STATE Normalize-Axiom ($B \sqsubseteq A$)
%\ENDFOR
%\end{algorithmic}
%\end{algorithm}

\textbf{Algorithm \ref{normalizeaxiom}}: O método \textit{Normalize-Axiom($A \sqsubseteq B$)} remove o axioma da ontologia (linha 1), remove as impurezas do dado esquedo (linha 2) e do lado direto (linha 3) do axioma. Caso ele já esteja na forma normal positiva (linha 3) apenas pela remoção das impurezas, ele será adicionado à base novamente (linha 5), caso contrário, dois axiomas serão criados, um com a expressão do lado esquerdo (linha 7) e outro com a expressão do lado direito (linha 8). Caso esses novos axiomas sejam criados, eles já estarão na forma normal positiva, já que uma expressão pura em uma relação de inclusão com um conceito está na forma normal positiva em qualquer combinação.

\begin{algorithm}
\caption{Normalize-Axiom ($A \sqsubseteq B$)}
\label{normalizeaxiom}
\begin{algorithmic}[1]
\REQUIRE {$A \sqsubseteq B$: inclusão de A em B}
\STATE $O = \{O - (A \sqsubseteq B) \} $
\STATE $pure\_left = $ purify $(A, left)$
\STATE $pure\_right = $ purify $(B, right)$
\IF [$S_{PNF}$ é o conjunto das fórmulas na forma normal positiva]{$(pure\_left \sqsubseteq pure\_right) \in S_{PNF}$}
\STATE $O = \{O \cup (pure\_left \sqsubseteq pure\_right)\} $
\ELSE
\STATE $O = \{O \cup (pure\_left \sqsubseteq N)\} $
\STATE $O = \{O \cup (N \sqsubseteq pure\_right)\} $
\ENDIF
\end{algorithmic}
\end{algorithm}

\textbf{Algorithm \ref{purify}}: O método \textit{purify ($e$, side)} recebe uma expressão em DL $ALC$ e a retorna sem impurezas. O parâmetro \textit{side} é necessário para remoção de uma impureza, caso a impureza esteja no lado esquerdo, e.g., $C \sqcap Impurity \sqcap C \sqcap C \sqsubseteq A$, um axioma será criado com a impureza do lado esquerdo, e.g., $(C \sqcap NewConcept \sqcap C \sqcap C \sqsubseteq A) \land (Impurity \sqsubseteq NewConcept)$, caso a impureza esteja no lado direito, o comportamento será o mesmo mas de forma simétrica, o seja, um axima do tipo $NewConcept \sqsubseteq Impurity$ será criado e a impureza será substituída por um novo conceito ($NewConcept$).

As impurezas são identificadas através dos métodos \textit{visit}. O método \textit{visit} em sua implementação em Java \footnote{código disponível em: http://github.com/adrianomelo/tg} utiliza o padrão de projetos visitor, que permite criar novas operações sem mudar a definição das estruturas de dados \cite{Gamma:1995}.

Uma pilha chamada \textit{expressions\_stack} é usada no método pois em uma implementação em Java os métodos que visitam cada nó da ontologia não podem retornar objetos por uma limitação da biblioteca OWLAPI 3.0 \footnote{documentação do método visit: 
http://owlapi.sourceforge.net/javadoc/org/semanticweb/owlapi/model/ OWLClassExpressionVisitor.html} \footnote{javadoc da documentação da OWLAPI 3.0: http://owlapi.sourceforge.net/javadoc/}.

\begin{algorithm}
\caption{purify ($e$, side)}
\label{purify}
\begin{algorithmic}[1]
\REQUIRE {e: uma expressão em DL $ALC$}
\REQUIRE {side: é $left$ ou $right$}
\STATE expressions\_stack = STACK()
\IF[$S_{npc}$ é o conjunto das conjunções não puras]{$e \in S_{npc}$}
\STATE visit (expressions\_stack, $e$, side, $conjunction$)
\ELSIF[$S_{npd}$ é o conjunto das disjunções não puras]{$e \in S_{npd}$}
\STATE visit (expressions\_stack, $e$, side, $disjunction$)
\ENDIF
\RETURN POP (expressions\_stack)
\end{algorithmic}
\end{algorithm}

\textbf{Algorithm \ref{alg:extractimpurity}}: O método \textit{Extract-Impurity()} é usado para criar um novo axioma na ontologia com a impureza achada por um dos métodos \textit{visit}. O parâmetro \textit{side} é utilizado para saber em qual lado do axioma a impureza deverá ficar. Após o a criação do axioma, o método \textit{Normalize-Axiom()} é chamado com o novo axioma para garantir que ele também esteja na forma normal positiva.

\begin{algorithm}
\caption{Extract-Impurity ($e$, side)}
\label{alg:extractimpurity}
\begin{algorithmic}[1]
\REQUIRE {e: uma expressão em DL $ALC$}
\REQUIRE {side: é $left$ ou $right$}
\STATE N = NEW-CONCEPT()
\IF{side = $left$}
\STATE $O = \{ O \cup (e \sqsubseteq N)\}$
\STATE Normalize-Axiom($e \sqsubseteq N$)
\ELSE
\STATE $O = \{ O \cup (N \sqsubseteq e)\}$
\STATE Normalize-Axiom($N \sqsubseteq e$)
\ENDIF
\RETURN N
\end{algorithmic}
\end{algorithm}

%\textbf{Algorithm 5, 6, 7, 8, 9, 10}: O conjunto de métodos chamados de \textit{visit} diferem em qual expressão em lógica de descrições cada um suporta. O método \textit{visit (stack, $\bigcup \limits^n e_i$, side, kind)}, por exemplo, dá suporte às uniões entre expressões.

\textbf{Algorithm \ref{alg:visitgeneral}}: O método \textit{visit} é utilizado para visitar cada nó da estrutura de árvore, que é a representação em memória da ontologia. O símbolo $\bigcup$ será usado na escrita do pseudo-código mas o algoritmo é o mesmo para os constructos $\forall, \bigcup, \bigcap$ e $\exists$, sendo que para $\exists$ e $\forall$ so haverá uma expressão filha.

Quatro parâmetros são passadados para os métodos, uma pilha \textit{stack} que é usada para auxiliar a construção de uma nova expressão normalizada. Uma expressão em lógica de descrições, que pode ser uma união $\bigcup \limits^n e_i$, interseção $\bigcap \limits^n e_i$, restrição  de valor $\forall r E$, restrição existencial $\exists r E$, complemento $\neg e$ ou conceito $C$. O lado \textit{side} em que a expressão original estava (\textit{left} ou \textit{right}). E o tipo \textit{kind} de expressão que o método estava esperando (\textit{conjunction} ou \textit{disjunction}).

Quando uma conjunção é passada para o método \textit{visit} e o tipo (\textit{kind}) é igual a \textit{disjunction}, significa que uma impureza foi encontrada e ela deve ser removida pelo método \textit{Extract-Impurity()}. De forma análoga, quando uma disjunção é visitada por um dos métodos \textit{visit} e o tipo esperado é \textit{conjunction}, significa que uma impureza foi encontrada e ela deve ser removida pelo método \textit{Extract-Impurity()}.

\begin{algorithm}
\caption{visit (stack, $\bigcup \limits^n e_i$, side, kind)}
\label{alg:visitgeneral}
\begin{algorithmic}[1]
\REQUIRE {stack: uma pilha}
\REQUIRE {side: é $left$ ou $right$}
\REQUIRE {$\bigcup \limits^n e_i$: constructo em $ALC$}
\IF{KIND\(\bigcup\) != kind}
\STATE N = Extract-Impurity($\bigcup \limits^n e_i$, side)
\STATE PUSH (stack, N)
\ELSE
\FORALL {$e_i \in \bigcup \limits^n e_i$}
\STATE visit  (stack, $e_i$, side, kind)
\ENDFOR
\STATE PUSH (stack, $\bigcup \limits^n$ POP(stack))
\ENDIF
\end{algorithmic}
\end{algorithm}

% ----------------------------- 
\begin{comment}
\begin{algorithm}
\caption{visit (stack, $\bigcup \limits^n e_i$, side, kind)}
\label{visitunion}
\begin{algorithmic}[1]
\REQUIRE {stack: uma pilha}
\REQUIRE {side: é $left$ ou $right$}
\REQUIRE {$\bigcup \limits^n e_i$: união de expressões $e_i$}
\IF{kind = $conjunction$}
\STATE N = Extract-Impurity($\bigcup \limits^n e_i$, side)
\STATE PUSH (stack, N)
\ELSE
\FORALL {$e_i \in \bigcup \limits^n e_i$}
\STATE visit  (stack, $e_i$, side, kind)
\ENDFOR
\STATE PUSH (stack, $\bigcup \limits^n$ POP(stack))
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{visit (stack, $\bigcap \limits^n e_i$, side, kind)}
\label{visitintersection}
\begin{algorithmic}[1]
\REQUIRE {stack: uma pilha}
\REQUIRE {side: é $left$ ou $right$}
\REQUIRE {$\bigcap \limits^n e_i$: interseção de expressões $e_i$}
\IF{kind = $disjunction$}
\STATE N = Extract-Impurity($\bigcup \limits^n e_i$, side)
\STATE PUSH (stack, N)
\ELSE
\FORALL {$e_i \in \bigcap \limits^n e_i$}
\STATE visit  (stack, $e_i$, side, kind)
\ENDFOR
\STATE PUSH (stack, $\bigcap \limits^n$ POP(stack))
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{visit (stack, $\forall r E$, side, kind)}
\label{visitforall}
\begin{algorithmic}[1]
\REQUIRE {stack: uma pilha}
\REQUIRE {side: é $left$ ou $right$}
\REQUIRE {$\forall r E$: restrição de valor com a relação $r$ e a expressão $E$ }
\IF{kind = $conjunction$}
\STATE N = Extract-Impurity($\bigcup \limits^n e_i$, side)
\STATE PUSH (stack, N)
\ELSE
\STATE $E'$ = NNF($E$)
\STATE visit (stack, $E'$, side, kind)
\STATE $E''$ = POP(stack)
\STATE PUSH (stack, $\forall r E''$)
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{visit (stack, $\exists r E$, side, kind)}
\label{visitexists}
\begin{algorithmic}[1]
\REQUIRE {stack: uma pilha}
\REQUIRE {side: é $left$ ou $right$}
\REQUIRE {$\exists r E$: restrição existencial com a relação $r$ e a expressão $E$ }
\IF{kind = $disjunction$}
\STATE N = Extract-Impurity($\bigcup \limits^n e_i$, side)
\STATE PUSH (stack, N)
\ELSE
\STATE $E'$ = NNF($E$)
\STATE visit (stack, $E'$, side, kind)
\STATE $E''$ = POP(stack)
\STATE PUSH (stack, $\exists r E''$)
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{visit (stack, $\neg e$, side, kind)}
\label{visitexists}
\begin{algorithmic}[1]
\REQUIRE {stack: uma pilha}
\REQUIRE {side: é $left$ ou $right$}
\REQUIRE {$\neg e$: negação de uma expressão $e$}
\IF {$E \notin S_{concept}$}
\STATE $e'$ = NNF($\neg e$)
\STATE visit (stack, $e'$, side, kind)
\ELSE
\STATE PUSH(stack, $\neg e$)
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{visit (stack, C, side, kind)}
\label{visitexists}
\begin{algorithmic}[1]
\REQUIRE {stack: uma pilha}
\REQUIRE {side: é $left$ ou $right$}
\REQUIRE {C: é um conceito}
\STATE PUSH (stack, C)
\end{algorithmic}
\end{algorithm}
\end{comment}
%--------------

%Para uma melhor comparação da matrizes que são geradas com o algoritmo proposto, o exemplo que Freitas et al \cite{Freitas:2010} também será o exemplo deste agoritmo. O axioma de equivalencia no Exemplo 1 é a base de conhecimento usada.


%\begin{exemplo}
%Deseja-se normalizar o axioma:
%
%\begin{center}
%$PizzaMargherita \equiv Pizza \sqcap \exists hasTopping.Tomate \sqcap \exists hasTopping.Muzzarella \sqcap \neg \exists hasTopping.\neg (Tomate \sqcup Muzzarella)$
%\end{center}
%
%O primeiro passo do algoritmo (método \textit{Normalize-Ontology()}, página \pageref{alg:normalizeontology}) separa o axioma de equivalência em dois axiomas de inclusão. Obtendo-se então:
%
%\begin{center}
%$PizzaMargherita \sqsubseteq Pizza \sqcap \exists hasTopping.Tomate \sqcap \exists hasTopping.Muzzarella \sqcap  \neg \exists hasTopping.\neg (Tomate \sqcup Muzzarella)$
%
%$Pizza \sqcap \exists hasTopping.Tomate \sqcap \exists hasTopping.Muzzarella \sqcap 
%\neg \exists hasTopping.\neg (Tomate \sqcup Muzzarella) \sqsubseteq PizzaMargherita$
%\end{center}
%
%O método \textit{Normalize-Axiom()} será chamado então com cada um dos axiomas obtidos. O lado direito no primeiro axioma e o lado esquerdo do segundo são conjunções, então o método \textit{visit} de interseções será chamado com o kind sendo \textit{conjunction} tanto para a primeira expressão quanto para a segunda.  
%
%Quando o método \textit{visit (stack, $\neg e$, side, kind)} for chamado com a expressão $\neg \exists hasTopping. \neg (Tomate \sqcup Muzzarella)$, tanto para o lado esquerdo, quanto para o lado direito ele a transformará na expressão $\forall hasTopping.(Tomate \sqcap Muzzarella)$, que é uma disjunção. Os axiomas que serão obtidos são:
%
%\begin{center}
%$PizzaMargherita \sqsubseteq Pizza \sqcap \exists hasTopping. Tomate \sqcap \exists hasTopping.Muzzarella \sqcap  Extracted1$
%
%$Extracted1 \sqsubseteq \forall hasTopping.(Tomate \sqcup Muzzarella)$
%
%$Pizza \sqcap \exists hasTopping.Tomate \sqcap \exists hasTopping.Muzzarella \sqcap 
%Extracted2 \sqsubseteq PizzaMargherita$
%
%$\forall hasTopping.(Tomate \sqcup Muzzarella) \sqsubseteq Extracted2$
%\end{center}
%
%Em formato matricial, temos (axiomas 1 e 2):
%
%\[
%\small{
%\begin{bmatrix}
%PM & PM & PM & PM & PM & PM & Extracted1\\
%\neg Pizza & \neg hasTopping & \neg Tomate & \neg hasTopping & \neg Muzzarella & \neg Extracted1 & \neg hasTopping\\
% & & & & & & \neg Tomate\\
% & & & & & & \neg Muzzarella\\
%\end{bmatrix}
%}
%\]
%
%e (axiomas 3 e 4):
%
%\[
%\begin{bmatrix}
%Pizza & \neg hasTopping & Tomate & Muzzarella \\
%hasTopping & \neg Extracted2 & \neg Extracted2 & \neg Extracted2 \\
%Tomate & & & \\
%hasTopping & & & \\
%Muzzarella & & & \\
%Extracted2 & & & \\
%\neg PizzaMargherita & & & \\
%\end{bmatrix}
%\]
%
%O algoritmo de Freitas et al \cite{Freitas:2010} chegou às mesmas matrizes. O que indica que ambos são lineares em relação às impurezas deste exemplo.
%
%\end{exemplo}

O Exemplo 1 mostra o caso em que o algoritmo original usa mais memória que o algoritmo proposto. O original é quadrático em relação à alocação memória em quanto que o proposto é linear.

\begin{exemplo}
No exemplo dado por Freitas et al \cite{Freitas:2010}, o seu algoritmo se comportava de forma linear (em espaço) em relação às impurezas nas expressões. Porém, com o caso $\hat{C} \sqsubseteq \hat{D}$, onde $\hat{C}$ e $\hat{D}$ são conjunções puras, o algoritmo se comporta de forma quadrática em relação a memória.

O algoritmo proposto irá dividir o axioma em dois, ficando $\hat{C} \sqsubseteq A$, e $A \sqsubseteq \hat{D}$. Já o algoritmo de Freitas et al, irá construir vários axiomas, um para cada expressão do lado direito, e.g., \{$\hat{C} \sqsubseteq D_1, \hat{C} \sqsubseteq D_2, ..., \hat{C} \sqsubseteq D_{m-1}, \hat{C} \sqsubseteq D_m$\}. O que irá resultar em uma matriz do tipo:

\begin{small}
\[
\begin{bmatrix}
C_1 & C_1 & \hdots & C_1 & C_1 \\
C_2 & C_2 & \hdots & C_2 & C_2 \\
\vdots & \vdots & \ddots & \vdots & \vdots \\
C_{n-1} & C_{n-1} & \hdots & C_{n-1} & C_{n-1} \\
C_n & C_n & \hdots & C_n & C_n  \\
\neg D_1 & \neg D_2 & \hdots & \neg D_{m-1} & \neg D_m
\end{bmatrix}
\]
\end{small}

enquanto que o algoritmo proposto irá produzir uma matriz do tipo:
\begin{small}
\[
\begin{bmatrix}
C_1 & A & A & \hdots & A & A\\
C_2 & \neg D_1 & \neg D_2 & \hdots & \neg D_{m-1} & \neg D_m\\
\vdots &  & & & & \\
C_{n-1} & & & & & \\
C_n & & & & & \\
\neg A & & & & & \\
\end{bmatrix}
\]
\end{small}
\end{exemplo}

\begin{comment}
\subsubsection{Algoritmo Original}

Esta seção contém o algoritmo escrito por Freitas et al \cite{Freitas:2010} para a normalização de bases de conhecimento em lógica de descrição $ALC$. A figura 3.1 descreve o método \textit{Normalize-Ontology ()}, que chama os métodos \textit{Normaize-LHS ()} e \textit{Normalize-RHS ()} caso o lado esquerdo e direito, respectivamente,  não estejam normalizados para cada axioma da ontologia.

Os métodos \textit{Normalize-LHS ()} e \textit{Normalize-RHS} são duais, ou seja, possuem a mesma lógica mas com o sentido invertido. A figura 3.2 mostra o pseudocódigo do método \textit{Normalize-LHS()} e a figura 3.3 mostra o pseudocódigo do método \textit{Normalize-RHS}.

\begin{figure}
\includegraphics[scale=0.7]{../imagens/normalize.png}
\caption{Método \textit{Normalize-Ontology ()}}
\label{fig:normalizeontology}
\end{figure}

 \begin{figure}
\includegraphics[scale=0.52]{../imagens/normalizelhs.png}
\caption{Método \textit{Normalize-LHS ()}}
\label{fig:normalizelhs}
\end{figure}

 \begin{figure}
\includegraphics[scale=0.52]{../imagens/normalizerhs.png}
\caption{Método \textit{Normalize-RHS ()}}
\label{fig:normalizerhs}
\end{figure}

Note que o primeiro algoritmo da seção 3.1.1 e a figura 3.1 são praticamente o mesmo, porém, o primeiro diferencia dentro do método os axiomas de equivalência e inclusão. No artigo de Freitas et al \cite{Freitas:2010} é citado que isso deve ser feito, mas não explicita no algoritmo.

\end{comment}

% !TEX encoding = ISO-8859-1
\chapter{Normalização para o método das conexões}
\label{ch:normalizacaoparaometododeconexoes}

O método das conexões proposto por W. Bibel \cite{bibel:1982} é um método para prova automática de teoremas descritos em lógica d primeira ordem ou em lógica proposicional \cite{bibel:1993}. Um dos trabalhos recentes de Freitas et al \cite{Freitas:2010} foi a extenção desse método para lógica de descrição $ALC$.

O artigo intitulado \textit{A Connection Method for Reasoning with the Description Logic ALC} \cite{Freitas:2010} propõe algoritmos tanto para o método, quanto para a normalização que precisa ser feita na base de conhecimento para que seja possível a representação necessária para o método das conexões usando apenas uma matriz. 

O objetivo deste trabalho é implementar algum algoritmo de normalização para o método das conexões como os citados no texto de Freitas et al. Dois algoritmos foram propostos com esse objetivo \cite{Freitas:2010}; o primeiro utiliza-se de uma tabela com nove regras que devem ser aplicadas à base de conhecimento a fim de obter a forma normal positiva. O segundo, intitulado "\textit{A more complex and efficient normalization}" não cria novos símbolos durante a sua execução, fazendo-o mais eficiente que o primeiro em relação ao uso de memória.

No cronograma deste trabalho estava prevista a implementação desse segundo algoritmo, porém, ao decorrer do desenvolvimento, o orientando propôs um terceiro algoritmo que é ainda mais eficiente em relação ao uso de memória, mas com o efeito colateral de precisar adicionar um símbolo a mais na base de conhecimento no pior caso. O restante desse capítulo se dedicará a dar definições para o entendimento dos últimos dois algoritmos comentados acima e também descrevá as suas implementações.

\section{Tradução de ontologias $ALC$ para forma normal disjuntiva}

Para que o leitor consiga entender melhor os algoritmos de tradução, alguns conceitos precisam ser fixados. 

Métodos diretos com o método das conexões são formulados para provar que uma fórmula ou um conjunto de fórmulas é um teorema, sse cada interpretação gerada é uma tautologia. Tautologias normalmente tomam a forma $L \lor \neg L$, nesse caso, a fórmula precisa estar na Forma Normal Disjuntiva (DNF).

\begin{definicao}[Forma Normal Disjuntiva, cláusula]
 Uma fórmula em DNF é uma conjunção de disjunções. Ou seja, tomam a forma:

\begin{center}
$\bigcup \limits_{i=1}^{n} C_i$ , ou, $C_1 \lor ... \lor C_n$.
\end{center}

onde cada $C_i$ é uma \textit{cláusula}. Uma cláusula é uma conjunção de literais. Ou seja, tomam a forma:

\begin{center}
$\bigcap \limits_{j=1}^m L_{i, j}$ , ou, $L_{i, 1} \land ... \land L_{i, m}$ , também representado por $\{ L_{i, 1}, ..., L_{i, m} \}$
\end{center}

onde cada $L_{i, j}$ é um literal, resultando na fórmula:

\begin{center}
$\bigcap \limits_{i=1}^n \bigcup \limits_{j=1}^m L_{i, j}$ , ou, $(L_{1,1} \land ... \land L_{1,m}) \lor (L_{n, 1} \land ... \land L_{n, m})$
\end{center}

podendo ser chamada também de forma causal disjuntiva, representada por: 

\begin{center}
$\{\{ (L_{1, 1}, ..., L_{1, m}\}, ..., \{L_{n, 1}, ..., L_{n, m} \}\}$
\end{center}

\end{definicao}

A definição acima é a definição herdada da lógica de primeira ordem, para ser válida também para a lógica de descrição o conceito de conjunções e disjunções deve ser estendido.

\begin{definicao}[Conjunção ALC]
Uma conjunção ALC é um literal $L$, uma conjunção $(E_0 \land , ..., \land E_n)$, ou uma restrição existencial $\exists x.E$, onde $E$ é uma expressão qualquer em lógica de descrição.
\end{definicao}

\begin{definicao}[Disjunção ALC]
Uma disjunção ALC é um literal $L$, uma disjunção $(E_0 \lor , ..., \lor E_n)$, ou uma restrição de valor $\forall x.E$, onde $E$ é uma expressão qualquer em lógica de descrição.
\end{definicao}

\begin{definicao}[Conjunção ALC pura, Conjunção ALC não pura]
Uma conjunção ALC pura é uma conjunção ALC que na forma normal negada não contém restrições de valor ($\forall x.E$) e também não contém disjunções $(E \lor , ..., \lor E)$. O conjunto de conjunções ALC puras é representado por $\hat{C}$. Uma conjunção ALC não pura é uma conjunção ALC que não é pura.
\end{definicao}

\begin{definicao}[Disjunção ALC pura, Disjunção ALC não pura]
Uma disjunção ALC pura é uma disjunção ALC que na forma normal negada não contém restrições existenciais ($\exists x.E$) e também não contém conjunções $(E \land , ..., \land E)$. O conjunto de disjunções ALC puras é representado por $\check{D}$. Uma disjunção ALC não pura é uma disjunção ALC que não é pura.
\end{definicao}

\begin{definicao}[Impureza em uma expressão não pura]
Impureza em expressões ALC não puras são conjunções em disjunções não puras ou disjunções em conjunções não puras. O conjunto de impurezas é chamado de \text{conjunto de impurezas ALC} e é representado por $I$.
\end{definicao}

\begin{definicao}[Forma Normal Positiva]
Um axioma ALC está na Forma Normal Positiva sse ele está em uma das seguintes formas: 

\begin{center}
i) $A \sqsubseteq \hat{C}$ \\
ii) $\check{D} \sqsubseteq A$ \\
iii) $\hat{C} \sqsubseteq \check{D}$ \\ 
\end{center}

onde A é um conceito atômico,  $\hat{C}$ é uma conjunção ALC pura, $\check{D}$ é uma disjunção ALC pura.

\end{definicao}

O método das conexões utiliza matrizes para realizar provas de teoremas. No início deste trabalho, ainda não era possível de fazer as provas com matrizes aninhadas, ou seja, havia sempre a necessidade de normalizar a base de conhecimento na forma normal positiva (definição 7). No entanto, Jens Otten em um trabalho entitulado \textit{A Non-clausal Connection Calculus} \cite{Otten:2011} mostrou como aplicar o método das conexões sem o passo da normalização. Apesar da recente evolucão do método, para o objetivo deste trabalho, ainda é necessário fazer a normalização, já que para lógica de descrição, o método ainda não foi modificado para usar matrizes aninhadas.

A próxima seção desta monografia descreve o algoritmo proposto pelo autor para a normalização para a forma normal positiva.


\subsection{Algoritmo Proposto}

Esta seção da monografia descreve a implementação realizada neste trabalho.

O método das conexões é um método direto, ou seja, uma consulta à base de conhecimento toma verifica se uma fórmla é uma tautologia e toma a forma $KB \rightarrow \alpha$, onde $\alpha$ é um axioma e $KB$ (\textit{Knowledge base}) é da forma $\bigcap \limits_{i=1}^{n} A_i$, onde $A_i$ também é um axioma. Expandindo a fórmula $\neg KB \lor \alpha$, temos:

$\neg \bigcap \limits_{i=1}^{n} A_i \lor \alpha$ [ou, $\neg (A_1 \land ... \land A_n) \lor \alpha$], que pode ser transformada para:

$\bigcup \limits_{i=1}^{n} \neg A_i \lor \alpha$ [ou, $\neg A_1 \lor ... \lor \neg A_n \lor \alpha$]

%, e $\alpha$ ainda é transformada para $\neg \neg\alpha$ para que as regras de normalização também se apliquem a ela, ficando:

%$\bigcup \limits_{i=1}^{n} \neg A_i \lor \neg \neg \alpha$ [ou, em uma forma por extenso, $\neg A_1 \lor ... \lor \neg A_n \lor \neg \neg \alpha$]

Cada $\neg A_i$ ou $\alpha$ precisam estar na forma normal positiva, ou seja, precisam estar em uma das formas: i) $A \sqsubseteq \hat{C}$, ii) $\check{D} \sqsubseteq A$, ou, iii) $\hat{C} \sqsubseteq \check{D}$, onde $A$ é um conceito, $\hat{C}$ é uma conjunção pura e $\check{D}$ é uma disjunção pura.

O primeiro passo do algoritmo é a separação de axiomas de equivalência de expressões e inclusões. Os axiomas de equivalência serão substituídos por dois axiomas de inclusão, e.g., $(A \equiv B \rightarrow A \sqsubseteq B \land B \sqsubseteq A)$.

\begin{algorithm}
\caption{Início do processo de normalização para toda a base de conhecimento}
\begin{algorithmic}
\FORALL [A, B são expressões, $S_{EQ}$ é o conjunto dos axiomas de equivalência]{$A \equiv B \in S_{EQ}$}
\STATE Normalize-Axiom ($A \sqsubseteq B$)
\STATE Normalize-Axiom ($B \sqsubseteq A$)
\ENDFOR
\FORALL [A, B são expressões, $S_I$ é o conjunto dos axiomas de inclusão]{$A \sqsubseteq B \in S_I$}
\STATE Normalize-Axiom ($A \sqsubseteq B$)
\ENDFOR
\end{algorithmic}
\end{algorithm}

A chamada ao método \textit{Normalize-Axiom()} remove as impuresas do lado esquerdo e do lado direito de cada axioma.

\begin{algorithm}
\caption{Normalize-Axiom ($A \sqsubseteq B)$)}
\begin{algorithmic}
\STATE $O = \{O - (A \sqsubseteq B) \} $
\STATE $pure\_left = $ purify $(A)$
\STATE $pure\_right = $ purify $(B)$
\IF [$S_{PNF}$ é o conjunto das fórmulas na forma normal positiva]{$(pure\_left \sqsubseteq pure\_right) \in S_{PNF}$}
\STATE $O = \{O \sqcup (pure\_left \sqsubseteq pure\_right)\} $
\ELSE
\STATE $O = \{O \sqcup (pure\_left \sqsubseteq N)\} $
\STATE $O = \{O \sqcup (N \sqsubseteq pure\_right)\} $
\ENDIF
\end{algorithmic}
\end{algorithm}

O método $purify (A)$ indentifica se $A$ (expressão em DL) é uma conjunção, disjunção ou conceito. Caso $A$ seja uma conjunção não pura, as impuresas são removidas, caso contrário, $A$ permanece com a estrutura original. De forma análoga, caso $A$ seja uma disjunção não pura, as impuresas serão removidas e $A$ passará a ser pura. E o último caso, caso $A$ seja um conceito, ele não será modificado. Ao remover uma impuresa, um axioma é adicionado à base com a expressão impura. O método \textit{Normalize-Axiom()} é então chamado com esse novo axioma adicionado.

O $if$ do método \textit{Normalize-Axiom ()} verifica se o axioma $A \sqsubseteq B$ está na forma normal positiva, caso não esteja, as expressões são separadas em dois axiomas para respeitar a tabela 3.1.

\begin{table}
\begin{center}
\begin{tabular}{ | c | c | } \hline
expressão & regra \\ \hline
$\hat{C_1} \sqsubseteq \hat{C_2}$ & $(\hat{C_1} \sqsubseteq A' ) \land (A' \sqsubseteq \hat{C_2})$  \\ \hline
$\check{D_1} \sqsubseteq \check{D_2}$ & $(\check{D_1} \sqsubseteq A' ) \land (A' \sqsubseteq \check{D_2})$ \\ \hline
$\check{D} \sqsubseteq \hat{C}$ & $(\check{D} \sqsubseteq A' ) \land (A' \sqsubseteq \hat{C})$ \\ \hline

\end{tabular}
\caption{Tabela de regras a serem aplicadas após o método purify}
\end{center}
\end{table}

\subsection{Algoritmo Original}

Esta seção contém o algoritmo escrito por Freitas et al \cite{Freitas:2010} para a normalização de bases de conhecimento em lógica de descrição $ALC$. A figura 3.1 descreve o método \textit{Normalize-Ontology ()}, que chama os métodos \textit{Normaize-LHS ()} e \textit{Normalize-RHS ()} caso o lado esquerdo e direito, respectivamente,  não estejam normalizados para cada axioma da ontologia.

\begin{figure}
\includegraphics[scale=0.7]{../imagens/normalize.png}
\caption{Método \textit{Normalize-Ontology ()}}
\label{fig:normalizeontology}
\end{figure}

Os métodos \textit{Normalize-LHS ()} e \textit{Normalize-RHS} são duais, ou seja, possuem a mesma lógica mas com o sentido invertido. A figura 3.2 mostra o pseudocódigo do método \textit{Normalize-LHS()} e a figura 3.3 mostra o pseudocódigo do método \textit{Normalize-RHS}.

 \begin{figure}
\includegraphics[scale=0.52]{../imagens/normalizelhs.png}
\caption{Método \textit{Normalize-LHS ()}}
\label{fig:normalizelhs}
\end{figure}

 \begin{figure}
\includegraphics[scale=0.52]{../imagens/normalizerhs.png}
\caption{Método \textit{Normalize-RHS ()}}
\label{fig:normalizerhs}
\end{figure}

Note que o primeiro algoritmo da seção 3.1.1 e a figura 3.1 são praticamente o mesmo, porém, o primeiro diferencia dentro do método os axiomas de equivalência e inclusão. No artigo de Freitas et al \cite{Freitas:2010} é citado que isso deve ser feito, mas não explicita no algoritmo.

Ao comparar o segundo algoritmo da seção 3.1.1 com as figuras 3.2 e 3.3 pode ser visto de forma clara que o algoritmo de normalização proposto ficou muito mais simples que o original.
